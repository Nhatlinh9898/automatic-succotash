<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web3D Framework + Server Integration Demo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .status-panel {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .status-item {
            text-align: center;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .status-item.online {
            border-color: #34d399;
            background: rgba(52, 211, 153, 0.1);
        }
        
        .status-item.offline {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }
        
        .controls {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #e0e7ff;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        input, textarea, select {
            flex: 1;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            color: white;
            font-size: 14px;
        }
        
        input::placeholder, textarea::placeholder {
            color: rgba(255,255,255,0.6);
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .viewport {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            height: 500px;
            position: relative;
        }
        
        #canvas-container {
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .response {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .response pre {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Web3D Framework + Server Integration</h1>
            <p>Demo k·∫øt h·ª£p Framework v·ªõi AI Servers</p>
        </div>
        
        <div class="status-panel">
            <div class="status-item" id="main-server-status">
                <h4>üåê Main Server</h4>
                <p id="main-server-text">Checking...</p>
            </div>
            <div class="status-item" id="ai-server-status">
                <h4>ü§ñ AI Server</h4>
                <p id="ai-server-text">Checking...</p>
            </div>
            <div class="status-item" id="framework-status">
                <h4>‚ö° Framework</h4>
                <p id="framework-text">Initializing...</p>
            </div>
            <div class="status-item" id="webgl-status">
                <h4>üéÆ WebGL</h4>
                <p id="webgl-text">Checking...</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>ü§ñ AI Controls</h3>
                <div class="input-group">
                    <input type="text" id="ai-input" placeholder="Nh·∫≠p prompt cho AI..." value="T·∫°o m·ªôt qu·∫£ c·∫ßu m√†u ƒë·ªè">
                    <button onclick="generateAI()">Generate</button>
                </div>
                <div class="button-grid">
                    <button onclick="createObject()">üé® T·∫°o Object 3D</button>
                    <button onclick="createShader()">‚ú® T·∫°o Shader</button>
                    <button onclick="batchProcess()">üì¶ Batch Process</button>
                    <button onclick="testTTS()">üîä Test TTS</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>üéÆ Framework Controls</h3>
                <div class="button-grid">
                    <button onclick="initFramework()">üîÑ Init Framework</button>
                    <button onclick="createScene()">üåê Create Scene</button>
                    <button onclick="addLight()">üí° Add Light</button>
                    <button onclick="exportState()">üì§ Export State</button>
                </div>
            </div>
        </div>
        
        <div class="viewport">
            <h3>üé¨ 3D Viewport</h3>
            <div id="canvas-container"></div>
        </div>
        
        <div class="response" id="response-panel" style="display: none;">
            <h3>üìù Response</h3>
            <pre id="response-content"></pre>
        </div>
    </div>

    <script type="module">
        // Import Three.js
        import * as THREE from 'https://cdn.skypack.dev/three@0.158.0';
        
        // Global variables
        let scene, camera, renderer, framework;
        let isInitialized = false;
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            checkServers();
            checkWebGL();
            initFramework();
        });
        
        // Check server status
        async function checkServers() {
            try {
                // Check main server
                const mainResponse = await fetch('http://localhost:3001/api/health');
                const mainData = await mainResponse.json();
                updateStatus('main-server', 'online', `OK (${mainData.provider})`);
            } catch (error) {
                updateStatus('main-server', 'offline', 'Offline');
            }
            
            try {
                // Check AI server
                const aiResponse = await fetch('http://localhost:8080/health');
                const aiData = await aiResponse.json();
                updateStatus('ai-server', 'online', 'OK');
            } catch (error) {
                updateStatus('ai-server', 'offline', 'Offline');
            }
        }
        
        // Check WebGL support
        function checkWebGL() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    updateStatus('webgl', 'online', 'Supported');
                } else {
                    updateStatus('webgl', 'offline', 'Not Supported');
                }
            } catch (error) {
                updateStatus('webgl', 'offline', 'Error');
            }
        }
        
        // Update status display
        function updateStatus(server, status, text) {
            const element = document.getElementById(`${server}-status`);
            const textElement = document.getElementById(`${server}-text`);
            
            element.className = `status-item ${status}`;
            textElement.textContent = text;
        }
        
        // Initialize framework
        async function initFramework() {
            try {
                updateStatus('framework', 'online', 'Initializing...');
                
                // Create basic Three.js scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a2e);
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 5, 10);
                camera.lookAt(0, 0, 0);
                
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(document.getElementById('canvas-container').clientWidth, 400);
                renderer.shadowMap.enabled = true;
                document.getElementById('canvas-container').appendChild(renderer.domElement);
                
                // Add basic lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // Add grid
                const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
                scene.add(gridHelper);
                
                // Add basic cube
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshStandardMaterial({ color: 0x4488ff });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.y = 1;
                cube.castShadow = true;
                scene.add(cube);
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    cube.rotation.x += 0.01;
                    cube.rotation.y += 0.01;
                    renderer.render(scene, camera);
                }
                animate();
                
                isInitialized = true;
                updateStatus('framework', 'online', 'Ready');
                showResponse('‚úÖ Framework initialized successfully!');
                
            } catch (error) {
                updateStatus('framework', 'offline', 'Error');
                showResponse(`‚ùå Framework initialization failed: ${error.message}`);
            }
        }
        
        // Generate AI content
        window.generateAI = async function() {
            const input = document.getElementById('ai-input').value;
            if (!input.trim()) return;
            
            showLoading(true);
            try {
                const response = await fetch('http://localhost:3001/api/ai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: input,
                        character: 'female1',
                        personality: 'friendly'
                    })
                });
                
                const data = await response.json();
                showResponse(`AI Response: ${data.reply}`);
                
                // Play TTS if available
                if (data.ttsUrl) {
                    const audio = new Audio(`http://localhost:3001${data.ttsUrl}`);
                    audio.play().catch(e => console.log('TTS failed:', e));
                }
                
            } catch (error) {
                showResponse(`AI Error: ${error.message}`);
            } finally {
                showLoading(false);
            }
        };
        
        // Create 3D object
        window.createObject = async function() {
            if (!isInitialized) {
                showResponse('‚ùå Framework not initialized');
                return;
            }
            
            const input = document.getElementById('ai-input').value;
            if (!input.trim()) return;
            
            showLoading(true);
            try {
                // Simple object creation based on keywords
                let geometry, material, mesh;
                
                if (input.toLowerCase().includes('c·∫ßu') || input.toLowerCase().includes('sphere')) {
                    geometry = new THREE.SphereGeometry(1, 32, 32);
                    material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                } else if (input.toLowerCase().includes('h·ªôp') || input.toLowerCase().includes('box')) {
                    geometry = new THREE.BoxGeometry(2, 2, 2);
                    material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                } else {
                    geometry = new THREE.ConeGeometry(1, 2, 32);
                    material = new THREE.MeshStandardMaterial({ color: 0x0000ff });
                }
                
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    1,
                    (Math.random() - 0.5) * 10
                );
                mesh.castShadow = true;
                scene.add(mesh);
                
                showResponse(`‚úÖ Created 3D object: ${input}`);
                
            } catch (error) {
                showResponse(`‚ùå Object creation failed: ${error.message}`);
            } finally {
                showLoading(false);
            }
        };
        
        // Create shader
        window.createShader = async function() {
            const input = document.getElementById('ai-input').value;
            if (!input.trim()) return;
            
            showLoading(true);
            try {
                const response = await fetch('http://localhost:3001/api/ai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: `Create GLSL shader for: ${input}. Provide vertex and fragment shader code.`,
                        character: 'female1',
                        personality: 'technical'
                    })
                });
                
                const data = await response.json();
                showResponse(`Shader Code:\n\n${data.reply}`);
                
            } catch (error) {
                showResponse(`‚ùå Shader creation failed: ${error.message}`);
            } finally {
                showLoading(false);
            }
        };
        
        // Batch process
        window.batchProcess = async function() {
            showLoading(true);
            try {
                const requests = [
                    { prompt: 'Create a red sphere' },
                    { prompt: 'Create a blue box' },
                    { prompt: 'Create a green cylinder' }
                ];
                
                const response = await fetch('http://localhost:8080/api/ai/batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ requests })
                });
                
                const data = await response.json();
                showResponse(`Batch processed ${data.totalProcessed} requests. Success: ${data.successful}`);
                
            } catch (error) {
                showResponse(`‚ùå Batch processing failed: ${error.message}`);
            } finally {
                showLoading(false);
            }
        };
        
        // Test TTS
        window.testTTS = async function() {
            const input = document.getElementById('ai-input').value;
            if (!input.trim()) return;
            
            showLoading(true);
            try {
                const response = await fetch('http://localhost:3001/api/ai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: input,
                        character: 'female1',
                        personality: 'friendly'
                    })
                });
                
                const data = await response.json();
                
                if (data.ttsUrl) {
                    const audio = new Audio(`http://localhost:3001${data.ttsUrl}`);
                    await audio.play();
                    showResponse(`üîä TTS played successfully`);
                } else {
                    showResponse(`‚ùå No TTS URL returned`);
                }
                
            } catch (error) {
                showResponse(`‚ùå TTS failed: ${error.message}`);
            } finally {
                showLoading(false);
            }
        };
        
        // Create scene
        window.createScene = function() {
            if (!isInitialized) {
                showResponse('‚ùå Framework not initialized');
                return;
            }
            
            // Add more objects to scene
            const geometries = [
                new THREE.TorusGeometry(1, 0.4, 16, 100),
                new THREE.OctahedronGeometry(1.5),
                new THREE.TetrahedronGeometry(1.5)
            ];
            
            const materials = [
                new THREE.MeshStandardMaterial({ color: 0xff6b6b }),
                new THREE.MeshStandardMaterial({ color: 0x4ecdc4 }),
                new THREE.MeshStandardMaterial({ color: 0x45b7d1 })
            ];
            
            geometries.forEach((geometry, index) => {
                const mesh = new THREE.Mesh(geometry, materials[index]);
                mesh.position.set(
                    (index - 1) * 4,
                    2,
                    0
                );
                mesh.castShadow = true;
                scene.add(mesh);
            });
            
            showResponse('‚úÖ Enhanced scene created');
        };
        
        // Add light
        window.addLight = function() {
            if (!isInitialized) {
                showResponse('‚ùå Framework not initialized');
                return;
            }
            
            const light = new THREE.PointLight(0xffffff, 1, 100);
            light.position.set(
                (Math.random() - 0.5) * 20,
                5,
                (Math.random() - 0.5) * 20
            );
            scene.add(light);
            
            showResponse('üí° Light added to scene');
        };
        
        // Export state
        window.exportState = function() {
            const state = {
                scene: {
                    objects: scene.children.length,
                    position: camera.position,
                    rotation: camera.rotation
                },
                framework: {
                    initialized: isInitialized,
                    webgl: renderer.capabilities
                },
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `framework-state-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showResponse('üì§ State exported successfully');
        };
        
        // Show response
        function showResponse(text) {
            const panel = document.getElementById('response-panel');
            const content = document.getElementById('response-content');
            
            panel.style.display = 'block';
            content.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
        }
        
        // Show loading
        function showLoading(show) {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(btn => {
                if (show) {
                    btn.disabled = true;
                    if (!btn.querySelector('.loading')) {
                        const loading = document.createElement('span');
                        loading.className = 'loading';
                        btn.appendChild(loading);
                    }
                } else {
                    btn.disabled = false;
                    const loading = btn.querySelector('.loading');
                    if (loading) loading.remove();
                }
            });
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = document.getElementById('canvas-container').clientWidth / 400;
                camera.updateProjectionMatrix();
                renderer.setSize(document.getElementById('canvas-container').clientWidth, 400);
            }
        });
    </script>
</body>
</html>
